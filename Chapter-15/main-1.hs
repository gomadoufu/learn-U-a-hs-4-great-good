{- 第15章 Zipper -}

-- Haskellの純粋性にはいいところがたくさんあるが、ある種の問題についてはちょっと工夫する必要がある

-- たとえば、Haskellではメモリ上の位置を元にして途中の値を識別することができない。すべて同じ値からなる木構造があった時、その情報のみでは各ノードを識別することはできない。非純粋な言語なら、メモリの位置で識別できる

-- 1つの方法は、たとえば木構造であれば、ルートからあるノードまでの経路を覚えておく方法がある。これはちゃんと動きはするが、効率が悪い

-- ある構造の注目点、および周辺の情報を含んでいるデータ構造はZipperと呼ばれる。Zipperは、いくつかのデータ構造に、そのデータ構造の一部分に注目するための機能をつけることで、データ構造を辿ったり更新したりする操作を簡単にしてくれる

-- データ構造の中で、注目点を上げたり下げたりするから、ジッパー。

{- 15.2 リストに注目する -}
-- リストのジッパーを作ってみる。ジッパーでは、データ構造の各要素に、それまで辿ってきた道など、これから訪れる要素に加え、元のデータ構造を復元できるような情報を記録する。

-- リストであれば、親ノードを記録しておくだけで良さそう

type ListZipper a = ([a], [a])

-- ここでは、前の[a]は注目している部分リスト、後ろの[a]はいわばぱんくずリストを表す

-- リストを前に進むには、注目している目の前のリストの一番最初を、ぱんくずリストの一番最初に追加する

goForward :: ListZipper a -> ListZipper a
goForward (x : xs, bs) = (xs, x : bs)

-- リストを後ろに戻るには、パンくずリストの一番最初を、リストの一番最初に追加する(戻す)

goBack :: ListZipper a -> ListZipper a
goBack (xs, b : bs) = (b : xs, bs)
