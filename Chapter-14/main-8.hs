{- 14.5 便利なモナディック関数特集 -}
-- モナド値を操作したり、モナド値を返したりする関数を紹介する
-- そのような関数はモナディック関数と呼ばれる

{- 14.5.1 liftMと愉快な仲間たち -}
-- すべてのモナドはアプリカティブファンクターであり、すべてのアプリカティブファンクターはファンクターであった。
-- つまりすべてのモナドはファンクターであるべきだけど、モナドのFunctorインスタンスに頼らなくても、liftM関数があれば、fmap相当のことが行える。

liftM :: (Monad m) => (a -> b) -> m a -> m b
-- fmap :: (Functor f) => (a -> b) -> f a -> f b

-- もしFunctorインスタンスとMonadインスタンスがそれぞれ法則を満たしているなら、fmapとliftMは全く同じものになる

liftM f m = m >>= (\x -> return (f x))

-- liftMはFunctor型クラスを参照せずに実装されている。このことから、モナドは少なくともファンクター以上に強い、と結論付けられる

-- アプリカティブファンクターとモナドの間にも、似たような関係がある
-- Applicative型クラスの能力は、普通の関数を、文脈付きの値に対してもあたかも普通の値であるかのように適用させてくれることだった。
-- Applicativeの関数として特徴的なのは、app関数だった
-- (<*>) :: (Applicative f) => f (a -> b) -> f a -> f b

-- fmapと同じように、appもMonad型クラスが提供する機能だけを使って実装できる。Applicativeの代わりにMonad型クラス制約がついているapp関数である、apというのがある。

ap :: (Monad m) => m (a -> b) -> m a -> m b
ap mf m = do
  f <- mf
  x <- m
  return (f x)

-- mfは、結果が関数であるようなモナド値のこと。
-- これで、モナドは少なくともアプリカティブ以上には強いということもわかった。

-- 実は、型がモナドであるとわかった時、Monadのインスタンスを書き上げてしまってから、単に「pureはreturnで<*>はapだ」と書いてApplicativeのインスタンスにすることがよくあるらしい。同じように、何かがMonadインスタンスになっていたら、それをFunctorインスタンスにするには、ただ「fmapはliftMだ」と言うだけのこともよくある。
