{- 11.3.5 IOもアプリカティブファンクターだよ！ -}
-- そうだよ。

-- instance Applicative IO where
--     pure = return
--     a <*> b = do
--         f <- a
--         x <- b
--         return (f x)

-- 1. pureがreturnなのは自然。だってpureがもうreturnぽいし。
-- 2. a <*> b の実装は、まずaという名のI/Oアクションを実行して関数を手に入れて、その関数をfという名前に束縛する。次にbを実行して、その結果の値をxという名前に束縛する。最後に、fをxに適用し、それを結果として返している。

-- Maybeと[]と異なり、IOの<*>演算子には「逐次実行」の意味が新たに加わっている。a <*> b <*> c のIOがあった時、それぞれのファンクターから値を取り出すためにはIOアクションを実行しなければならないので、自然に a -> b -> cの順番でIOが逐次実行される。

{- 11.3.6 関数もアプリカティブだよ -}
-- だよ。

-- instance Applicative ((->) r) where
--     pure x = (_ -> x)
--     f <*> g = \x -> f x (g x)

-- 1. ある値をpureを使ってアプリカティブ値に包んだものは、元の値を生み出せないといけない。そこで、pureはidのように実装されている。
-- 2. <*>の型 f (a -> b) -> f a -> f b からわかるように、<*>演算子を２つの引数に適用すると、fで包まれたアプリカティブ値が返ってくる。ここではfは関数なので、f <*> g は関数が返ってくる。

{- 11.3.7 Zipリスト -}
-- 実は、リストをアプリカティブファンクターにする方法は複数ある。1つの方法は、二つのリストの値のあらゆる可能な組み合わせを作るものだった。
-- 例えば、[(+3),(*2)] <*> [1,2]と書いたら、2×2で4つの要素を持つリスト[(+3 1),(+3 2),(*2 1),(*2 2)] = [4,5,2,4]になる。でも、例えば1つ目の値は1つ目の値、2つ目の値は2つ目の値に適用して、[(+3 1),(*2 2)]ではダメなのだろうか？

-- リストをアプリカティブファンクターにする別の方法として、このような考え方で計算をするZipList型がある。

-- instance Applicative  zipList where
--     pure x = ZipList (repeat x)
--     ZipList fs <*> ZipList xs = ZipList (zipWith (\f x -> f x) fs xs)

{- 11.3.8 アプリカティブ則 -}
-- ファンクターのように、アプリカティブファンクターにもいくつか法則がある。
-- 一番重要な法則は、
--   pure f <*> x = fmap f x

-- このほかに、以下の法則がある
-- pure id <*> v = v
-- pure (.) <*> u <*> v <*> w = u <*> (v <*> w)
-- pure f <*> pure x = pure (f x)
-- u <*> pure y = pure ($ y) <*> u

{- 11.4 アプリカティブの便利な関数 -}

liftA2 :: (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
liftA2 f a b = f <$> a <*> b

-- この関数は、「通常の2引数関数を、2つのアプリカティブ血を引数に取る関数に昇格させる」関数だと見なすことができる。

-- 例えば、Just 3 と Just [4] から、Just[3,4]を作るにはどうしたらいいか？
-- liftA2 (:) (Just 3) (Just [4])
-- 好きな数のアプリカティブ値たちから、それらの返り値をリストにしたものを持つ単一のアプリカティブ値を組み立てることができそうだ。

-- 今度は、「アプリカティブ値のリスト」を取って「それらのリストのアプリカティブ値」を返す関数を実装してみる

sequenceA :: (Applicative f) => [f a] -> f [a]
sequenceA = foldr (liftA2 (:)) (pure [])

-- sequenceA [Just 3, Just 2, Just 1] = Just [3, 2, 1]
-- sequenceA [[1, 2, 3], [4, 5, 6]] = [[1, 4], [1, 5], [1, 6]]

-- IOアクションにこのsequenceAを使った時の動きは、まさにsequence関数そのもの！
-- sequenceA [getLine, getLine, getLine] ... getLineが3回実行される。単一のアプリカティブ値にまとめるためには、すべてのIOアクションを順に実行しなければならないから。

-- 「まとめると、アプリカティブファンクターは、面白い上にとても便利なものです。
--  アプリカティブファンクターを使えば、I/Oを伴う計算、非決定性計算、失敗するかもしれない計算、などなど、
--  多種多様な計算をアプリカティブ・スタイルを使って組み合わせることができます。
--  <$>と<*>を使うだけで、普通の関数をどんなアプリカティブファンクターとも組み合わせて使うことができ、それぞれのアプリカティブファンクターの文脈の力を借りることができるのです。」
