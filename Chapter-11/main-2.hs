{- 11.3 アプリカティブファンクターを使おう -}
-- これまで、ファンクター値を写すために、もっぱら1引数関数を使ってきた。では、2引数関数を使うとどうなるか？

-- 一般に、他引数関数でファンクター値を写すと、関数が入ったファンクター値が返ってくる。
-- let a = fmap (*) [1, 2, 3, 4]
-- aは [(1*), (2*), (3*), (4*)]になっている

-- 関数が入ったファンクター値は、その関数を引数に取れるような方を持つ関数でfmapする使い道がある
-- let b = fmap ($9) a
-- aはリストであり、そこから値を取り出し、9を関数適用して、リストに戻す
-- bは [9, 18, 27, 36] になっている

-- では、ファンクター値 Just (3*)とファンクター値 Just 5があったとして、Just (3*)から関数を取り出してJust 5の中身に適用することはできるか？
-- A.できない。ファンクターは、「通常の関数」でファンクター値の中身を写すことしかできない。もちろん、Just (3*)をパターンマッチして中身の関数を取り出せばよいが、それではMaybe限定の手段になってしまう。これを抽象的な手段で実現するには、アプリカティブファンクターを用いる。

{- 11.3.1 Applicativeちゃん と仲良くしてあげてね！ -}

-- class (Functor f) => Applicative f where
--   pure :: a -> f a
--   (<*>) :: f (a -> b) -> f a -> f b

-- 1. Applicativeクラスには、Functorの型クラス制約がある。つまりApplicativeクラスのインスタンスではfmapが使える
-- 2. pureは任意の型の引数を受け取り、それをアプリカティブ値の中に入れて返す。値を引数にとり、元の値を再現できるような最小限の純粋な文脈に置く、というイメージ
-- 3. <*> 、fmap(fmap:: (a -> b) -> f a -> f b)にそっくり！ <*>はfmapの強化版で、「関数の入っているファンクター値」と「値の入っているファンクター値」を引数にとって、前者のファンクターの中身である関数を後者のファンクターの中身に適用して、その結果をファンクターに入れて返す。中置演算子であることに注意

{- 11.3.2 Maybeはアプリカティブファンクター -}

-- instance Applicative Maybe where
--   pure = Just
--   Nothing <*> _ = Nothing
--   (Just f) <*> something = fmap f something

-- 1. 最小の文脈はNothingじゃなくてJust。値ないと仕方ないので。
-- 2. f(a -> b)がNothingなら、問答無用でNothing
-- 3. 関数の方がJustで包まれている時、それからfを取り出して、アプリカティブ値somethingにfmapしたものを返す

-- Applictiveのクラス定義にはFunctorの型クラス制約がついていたので、somethingは必ずFunctorであることに注意。また、その型クラス制約のため、インスタンス定義でfmapが使える

{- 11.3.3 アプリカティブ・スタイル -}

-- Applicative型クラスでは、<*>を連続して使うことで、複数のアプリカティブ値を組み合わせて使うことができる。
-- pure (+) <*> Just 3 <*> Just 5  のように。
-- このスタイルを使うと、普通の関数funcに対して pure f <*> x <*> y <*> ... のように書くことで、普通の関数にも幾つでもアプリカティブ値の引数を与えることができる。

-- アプリカティブスタイルで気にするポイントとして、
-- pure f <*> x = fmap f x
-- がある。pure f <*> x <*> y <*> ...と書く代わりに、fmap f x <*> y <*> ...と書くことができる。

-- この書き方はよく使うので、Control.Applicativeに fmapと等価な演算子<$> がある。

-- (<$>) :: (Functor f) => (a -> b) -> f a -> f b
-- f <$> x = fmap f x

-- これを使うことで、アプリカティブスタイルはさらに
-- f <$> x <*> y <*>...と書ける。綺麗。

{- 11.3.4 リスト -}
-- リスト型コンストラクタ [] もアプリカティブファンクター。

-- instance Applicative [] where
--   pure x = [x]
--   fs <*> xs = [f x | f <- fs, x <- xs]

-- 1. 文脈を保っている、意味のある最小の値は[x]。[]はMaybeでいうNothingであり、値を持っていないので、pureには適さない
-- 2. リストの<*>は、左辺の関数リストのそれぞれの関数を、右辺のリストのそれぞれの値に適用する。結果、<*> が返すリストは、左辺のリストの中の関数を右辺のリストの中のあらゆる可能な組み合わせで適用したリスト(つまりfsとxsの直積集合。要素数 N(fs)×N(xs))になる。

-- リストの<*>計算は、可能な非決定性計算の解の集合同士を掛け合わせて、あたらしい非決定性計算の解の集合を作っていると考えることができる。
