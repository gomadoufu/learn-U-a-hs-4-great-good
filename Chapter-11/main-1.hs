{- 11 ファンクターからアプリカティブファンクターへ -}
-- ファンクターとは関数で写せるもののことだった
-- 例えば、リスト、Maybe、木構造など

-- ファンクターは型クラスFunctorで表現される。
-- ファンクターの型クラスメソッドは fmap 1つだけ

-- fmap :: Functor f => (a -> b) -> f a -> f b
-- ファンクターは、「文脈fを保ったまま、関数を値に適用するもの」と考えることもできる

-- 型コンストラクタをFunctorのインスタンスにするには、その型のカインドは * -> * でなければならない。つまり、Functorのインスタンスになるには、具体型をただ一つとって具体型を一つ生むような型でなければならない。* -> *の形でないなら、部分適用してこの形にするのもよい。

{- 11.1.1 ファンクターとしてのIOアクション -}

-- IOアクションもFunctorのインスタンス

-- instance Functor IO where
--     fmap f action = do
--         result <- action
--         return (f result)

-- IOアクションから値を取り出して、関数を適用し、returnでまたIOアクションに戻している(文脈を保つ)

{- 11.1.2 ファンクターとしての関数 -}

-- なんと、関数の型を表す r -> a の (->) r も、ファンクターだった。 -> だけだとカインドが * -> * -> * なので、rを部分適用している。

-- fmap :: (a -> b) -> ((->) r a) -> ((->) r b)
--  = fmap :: (a -> b) -> (r -> a) -> (r -> b)

-- instance Functor ((->) r) where
--   fmap f g = (\x -> f (g x))
-- これ、関数合成を意味している。fmapを関数に適用すると、関数合成になる！

-- 関数ファンクター (->) r は、「r型の入力を適用すれば結果が返ってくる」 という文脈を表している

-- さて、fmapの型は
-- fmap :: Functor f => (a -> b) -> f a -> f b
-- だが、これを
-- fmap :: Functor f => (a -> b) -> (f a -> f b)
-- と見ると、fmapは「引数にとった関数(a -> b)に似ているけれど、ファンクター値をとってファンクター値を返す関数」を返す関数とも見える。こういった操作を、関数の持ち上げという。

{- 11.2 ファンクター則-}
-- ファンクター則が満たされたファンクターなら、fmapを使っても、関数でファンクター値の中身が変化するだけで、それ以外のことは何も起こらないことが保証できる

-- 第一法則 idでファンクター値を写した場合、ファンクター値が変化してはいけない
-- fmap id = id

-- 第二法則 「fとgの合成関数でファンクター値を写したもの」と「まずg、次にfでファンクター値を写したもの」が等しくなくてはならない
-- fmap (f . g) = fmap f . fmap g
